\chapter{Cosmological Simulations}
Cosmic Linear Anisotropy Solving System \parencite[CLASS,][]{class}

For a comparison with standard gravity we also used linear and non-linear power spectra $P(k)$ generated by the CosmicEmu emulator \parencite{Heitmann:2015xma}

Core Cosmology Library \parencite{2018arXiv181205995C}

Gauss-Seidel relaxation \parencite{doi:10.1002/zamm.19720520813}

full approximation scheme \parencite[FAS, see, e.g.,][]{MG_overview}

initial conditions with opposite phases to accelerate convergence \parencite{PhysRevD.93.103519}.

Numerical Recipes \parencite{10.5555/42249}

\todo{Notation \(n,N,L,m\)

}

\section{\nbody\ problem}
Many problems in physics, including cosmology, involve particle systems with each particle interacting with all other particles present. In astronomy there is a gravitational interaction between starts, galaxies and cluster of galaxies, depending on scale which we are studying. The challenge of efficiently carrying out the related calculations is generally known as the \nbody\ problem.

The main problem is following -- we have $N_p$ particles all interacting gravitationally with each other. To compute a trajectory of even a single particle involves computing trajectories of all other particles as the gravitational force is dependent on time-varying positions of other particles. That means that at each time-step we have to compute force from all other $N_p$ particles and we need to compute these forces for each of $N_p$ particles. This leaves us with complexity of \(\OO(N_p^2)\). This brute force approach can be used only for small systems and is computationally unimaginable for large systems in cosmology which typically involve \(N_p\sim10^{9}\) particles.

This direct approach is generally referred to as the Particle-Particle (PP) method \parencite{Hockney:1988:CSU:62815}. Although computationally expensive the accuracy in the force calculation is of machine precision. To be able to simulate large systems of particles we need to drop the accuracy of continuous positions and use discrete positions for force calculations. In our code we use two main methods for force calculations -- the Particle-Mesh algorithm (PM) and grid-based methods, both of them we describe in more details below.
\subsection{Time integration}
The accurate time integration is a very important part of any \nbodysim. While there are many different methods to integrate particle trajectories \parencite[see e.g.][]{Hockney:1988:CSU:62815} we describe here one of the most used one in collisionless simulations -- the Leapfrog integrator.

The leapfrog integrator is an example of a symplectic integrator. Symplectic integrators exactly solve an approximate Hamiltonian. As a consequence, the numerical time evolution is a canonical map and preserves certain conserved quantities exactly, such as the total angular momentum, the phase-space volume, and the Jacobi constants. The idea is to approximate the Hamiltonian \(H\) governing motion of particles with an approximat one
\eq{
    \tilde H=H+H\err\,,
}
where \(H\err\) is the error Hamiltonian. Provided that \(\tilde H\) and \(H\) are time-invariant, the energy error is bounded at all times. The goal now is to find \(\tilde H\) that can be solved exactly by simple numerical means and minimises \(H\err\). Defining the combined phase-space coordinates \(w\equiv(x,p)\) the Hamilton’s equations are
\eq{
    \dot w=\HH w\,,
}
where \(\HH\equiv\{\cdot,H\}\) is an operator acting on \(w\) through Poisson bracket. Hamilton’s equations have then the formal solution
\eq{
    w(t+\Delta t)=e^{\Delta t\HH}w(t)\,.
}
\begin{sloppypar}
The operator \(e^{\Delta t\HH}\) can be split, in an approximate sense, into a succession of discrete but symplectic steps, each of which can be exactly integrated. The most common choice is to separate out the kinetic and potential energies, \({H=T(p)+V(x)}\), such that we can split
\end{sloppypar}
\eq{
    \label{eq:kdk}
    e^{\Delta t\HH}= e^{\Delta t(\TT+\VV)}\approx e^{\frac12\Delta t\VV}e^{\Delta t\TT}e^{\frac12\Delta t\VV}\,,
}
where operators \(\TT\equiv\{\cdot,T\}\) and \(\VV\equiv\{\cdot,V\}\) are known as drift and kick, as they only change either the positions (drift) or velocities (kick). Because these operators are non-commutative, the central relation in \eqref{eq:kdk} is only approximately true. This operator splitting is extremely useful, because the new equations have simple solution:
\eq{
    e^{\Delta t\TT}
    \begin{pmatrix}
        x \\
        p \\
    \end{pmatrix}=
    \begin{pmatrix}
        x+\Delta t\ p \\
        p \\
    \end{pmatrix}
    \mspace{20mu}\rm{and}\mspace{20mu}
    e^{\Delta t\VV}
    \begin{pmatrix}
        x \\
        p \\
    \end{pmatrix}=
    \begin{pmatrix}
        x \\
        p-\Delta t\ \nabla V \\
    \end{pmatrix}\,.
}
The splitting \eqref{eq:kdk}, also known as kick-drift-kick (KDK), is second order accurate, whereas simpler splitting only into one kick and one drift is first order accurate. The same accurcy and results has also similar splitting into drift-kick-drift which we use in our integrator.
\section{Particle-Mesh algorithm}
As we mentioned in the introduction in order to effectively compute forces on particles one has to abandon continuous position and solve the forces using discretized positions. The idea of the PM method is that we set up a mesh (grid) over the computational box, and then solve the gravitational potential (i.e. Poisson’s equation \eqref{eq:poisson_lin}) at the meshpoints. Forces at the meshpoints can then be obtained by calculating the gradient of the potential. The four principal steps of the particle-mesh calculation are:
\begin{enumerate}
    \item assign mass to the mesh,
    \label{it:pm_1}
    \item solve the field equation on the mesh,
    \label{it:pm_2}
    \item calculate the mesh-defined force field,
    \label{it:pm_3}
    \item interpolate to find forces on the particles,
    \label{it:pm_4}
\end{enumerate}
where the forces found at the last step are used to integrate the equations of motion.
\subsection{Assignment schemes}
In step \ref{it:pm_1} and \ref{it:pm_4} we make a connection between discrete mesh and continuous positions of the particles. In the first we need to distribute mass of all particles onto the mesh and in the last step, on the contrary, we need to interpolate forces known on the discrete mesh onto particles with continuous positions. There are several ways of assigning the particle masses to the discrete density function $\delta$ and discrete force $-\nabla\Phi$ to the particles:

\subsubsection{Nearest gridpoint (NGP)}
The mass of each particle $m_i$ is assigned as a whole to the gridpoint closest to the particle. Similary, force on particles is given by force on the nearest gridpoint. Although computationally the simplest, NGP as a zero-order interpolation offer lowest accuracy and the interparticle force changes discontinuously as particles cross cell boundaries.

\subsubsection{Cloud-in-Cell (CIC)}
The mass of each particle is weighted over the eight closest cells while the the weighting in each dimension is proportional to the distance between particle and the mesh. CIC scheme is more costly in terms of number of arithmetic operations per particle per timestep than NGP but offers better accuracy as first order (linear) interpolation. The CIC interpolation function in one dimension is
\eq{
    w(x-x_p)=
    \begin{cases}
        1-\frac{|x-x_p|}{H} & |x-x_p|<H\,\\
        0 & \rm{otherwise}
    \end{cases}
}
where $x$ is the position of a mesh point, $x_p$ position of the partice and $H$ the distance between mesh points. The three-dimensional interpolation function is \(W(\mathbf x)=w(x_1)w(x_2)w(x_3)\). The CIC scheme is somewhere in the middle between oversimplistic NGP and higher order interpolations which offer greater accuracy and smoother transitions but at the cost of much greater computational resources -- second order interpolation (triangular shaped cloud, TSC) involves 27 cells, third order 64, and etc. CIC gives a much smoother force than the NGP scheme (piecewise linear) and reduces the amplitude of fluctuations in the interparticle forces as the particles are displaced with respect to the mesh. In our code we use the CIC scheme.
\subsubsection{Mixed schemes}
The NGP and CIC schemes both employ mass assignment functions which are the same as their force interpolation functions. A result of this symmetry is that they conserve momentum, i.e., the forces between a pair of particles are equal and opposite, and the force of a particle upon itself (the self force) is zero. A possible variation is to use a mass assignment function which is different from the force interpolation function. In such cases, symmetry still causes the force between pairs of particles to be equal and opposite, but no longer ensures that the self force is zero. At best, the presence of the self force presents a nonphysical restriction on the timestep and, at worst, it is disastrous.

\subsection{Solution of the field equations}
An efficient method for the solution of the field equations is a necessary requirement for the practical implementation of the particle simulation algorithms that have been described. For linear Poisson’s equation \eqref{eq:poisson_lin} the most used method is the Fast Fourier Transformation whcih can compute convolutions involve in the force computation rapidly with complexity of $\OO(N_m\log N_m)$. The FFT also automatically solves periodic boundary conditions usually incorporated in cosmological simulations to enforce homogeneity and isotropy of the Universe.

The Green's function $G(k)$ of \eqref{eq:poisson_lin} is not the expected one, $-1/k^2$, but we have the freedom to choose such a Green`s function which will minimize errors introduce by all the steps involve in force calculation -- mass assignment, potential solver, finite difference and force interpolation. This topic is in great detail studied in \textcite{Hockney:1988:CSU:62815}.
\subsection{Particle-Particle Particle Mesh algorithm}
The PM methods are excellent for solving long-range forces between particles as these methods are very fast and accurate. However, this accuracy is limited by the mesh size $H$ and PM algorithms cannot truly describe anything below this scale. The accuracy is given by the Nyquist wavelength $\lambda_N=2H$, which is the shortest spatial wavelength that can be accurately recovered. Similar, power on wavenumbers larger than the Nyquist wavenumber $k_N=2\pi/\lambda_N=N_m\pi/L$ will be aliased into longer waves. To overcome this limitations Particle-Particle Particle Mesh algorithms (P$^3$M) have neen proposed \textcite{hockney_10000_1973}.

The essence of the method is to express the interparticle force as the sum of two component parts; the short-range part, which is nonzero only for particle separations less than some cutoff radius, and the smoothly varying long-range part, which has a transform which is approximately band-limited (that is to say, is approximately nonzero for only a limited range of $k$). The total short-range force on a particle is computed by direct particle-particle (PP) pair force summation and the smoothly varying part is approximated by the particle-mesh (PM) force calculation.

We do not use P$^3$M in our approximate methods because of their much greater numerical requirements compared to simpler PM methods. For more details, see e.g. \textcite{Hockney:1988:CSU:62815}.
\section{Grid-based methods}
\todo{need to solve non-linear equations

Gaus-Seidel relaxation method

Multigrid methods

The Fast Multipole Method}
\section{Other methods}
\subsection{TreePM}
\section{Alternatives to \nbody\ simulations}
\todo{Boltzmann equation, orbit averaging, Monte-Carlo}

\section{Validation}